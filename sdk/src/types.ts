/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Health check
         * @description Returns the health status of the API and database connection. Does not require authentication.
         */
        get: operations["getHealth"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/query/{table}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Select rows
         * @description Query rows from a table with optional filtering, ordering, pagination, and nested relations.
         *
         *     Use query parameters for WHERE conditions (e.g., `id=eq.1`).
         *
         *     **Aggregations**: Use aggregate functions in select parameter:
         *     - `select=count(*)` - Count all rows
         *     - `select=category,sum(price)` - Group by with aggregates
         *
         *     **Row Count**: Add `Prefer: count=exact` header to include total count in `X-Total-Count` response header.
         *     Use `count=only` parameter to get only the count without data.
         */
        get: operations["selectRows"];
        put?: never;
        /**
         * Insert row
         * @description Insert a single row into a table.
         *
         *     To perform an upsert (insert or update on conflict), add the header:
         *     ```
         *     Prefer: resolution=merge-duplicates
         *     ```
         *     For upsert, the request body should be an array of objects.
         */
        post: operations["insertRow"];
        /**
         * Delete rows
         * @description Delete rows matching the WHERE conditions from query parameters.
         *
         *     **A WHERE clause is required** - mass deletes without conditions are not allowed.
         */
        delete: operations["deleteRows"];
        options?: never;
        head?: never;
        /**
         * Update rows
         * @description Update rows matching the WHERE conditions from query parameters.
         *
         *     Use query parameters for WHERE conditions (e.g., `id=eq.1`).
         */
        patch: operations["updateRows"];
        trace?: never;
    };
    "/schema": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all tables
         * @description Get a list of all tables in the database schema with their columns and primary keys.
         */
        get: operations["getSchema"];
        put?: never;
        /**
         * Execute DDL query
         * @description Execute a raw DDL (Data Definition Language) SQL query.
         *
         *     **Only DDL statements are allowed** (CREATE, ALTER, DROP, etc.). DML statements (SELECT, INSERT, UPDATE, DELETE) will be rejected.
         */
        post: operations["executeSchema"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/schema/invalidate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Invalidate schema cache
         * @description Force a refresh of the schema cache.
         *
         *     Call this after making schema changes outside of Atomicbase or if the cache becomes stale.
         */
        post: operations["invalidateSchema"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/schema/table/{table}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get table schema
         * @description Get the schema definition for a specific table including columns, primary key, and foreign keys.
         */
        get: operations["getTableSchema"];
        put?: never;
        /**
         * Create table
         * @description Create a new table with the specified columns and constraints.
         */
        post: operations["createTable"];
        /**
         * Drop table
         * @description Drop (delete) a table and all its data.
         */
        delete: operations["dropTable"];
        options?: never;
        head?: never;
        /**
         * Alter table
         * @description Modify an existing table structure (add columns, rename columns, drop columns, rename table).
         */
        patch: operations["alterTable"];
        trace?: never;
    };
    "/schema/fts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List FTS indexes
         * @description List all tables that have FTS5 (Full-Text Search) indexes configured.
         *
         *     Returns information about each FTS index including the base table name, FTS table name, and indexed columns.
         */
        get: operations["listFTSIndexes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/schema/fts/{table}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create FTS index
         * @description Create an FTS5 (Full-Text Search) index on a table.
         *
         *     This creates:
         *     - An FTS5 virtual table named `{table}_fts`
         *     - Triggers to keep the FTS index synchronized with the source table
         *
         *     **Requirements:**
         *     - All specified columns must be TEXT type
         *     - The table must not already have an FTS index
         *
         *     After creating an FTS index, you can use the `fts` operator in queries:
         *     ```
         *     GET /query/articles?title=fts.search+terms
         *     ```
         */
        post: operations["createFTSIndex"];
        /**
         * Drop FTS index
         * @description Remove an FTS5 index from a table.
         *
         *     This drops:
         *     - The FTS5 virtual table `{table}_fts`
         *     - Associated synchronization triggers
         *
         *     The source table data is not affected.
         */
        delete: operations["dropFTSIndex"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/db": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List databases
         * @description List all registered external databases (Turso).
         */
        get: operations["listDatabases"];
        put?: never;
        /**
         * Create database
         * @description Create a new Turso database.
         *
         *     Requires `TURSO_ORGANIZATION` and `TURSO_API_KEY` environment variables.
         */
        post: operations["createDatabase"];
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Register database
         * @description Register an existing Turso database with Atomicbase.
         *
         *     Optionally provide a database token via the `DB-Token` header. If not provided, a new token will be created.
         */
        patch: operations["registerDatabase"];
        trace?: never;
    };
    "/db/all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Register all databases
         * @description Discover and register all Turso databases in your organization.
         *
         *     Requires `TURSO_ORGANIZATION` and `TURSO_API_KEY` environment variables.
         */
        patch: operations["registerAllDatabases"];
        trace?: never;
    };
    "/db/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete database
         * @description Delete a Turso database.
         *
         *     **Warning**: This permanently deletes the database from Turso, not just from Atomicbase.
         */
        delete: operations["deleteDatabase"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        ErrorResponse: {
            /** @description Error message */
            error: string;
        };
        MessageResponse: {
            message: string;
        };
        HealthResponse: {
            /** @enum {string} */
            status: "healthy" | "unhealthy";
            /** @description Error details when unhealthy */
            error?: string;
        };
        InsertResponse: {
            /** @description ID of the inserted row */
            last_insert_id?: number;
        };
        RowsAffectedResponse: {
            /** @description Number of rows affected */
            rows_affected?: number;
        };
        CountResponse: {
            /** @description Total number of matching rows */
            count: number;
        };
        SchemaQueryRequest: {
            /** @description DDL SQL query to execute */
            query: string;
            /** @description Query arguments (for parameterized queries) */
            args?: unknown[];
        };
        /** @description Table schema information */
        Table: {
            /** @description Table name */
            name: string;
            /** @description Primary key column name (empty if using rowid) */
            pk?: string;
            columns: components["schemas"]["Column"][];
        };
        /** @description Column definition */
        Column: {
            /** @description Column name */
            name: string;
            /**
             * @description Column type (TEXT, INTEGER, REAL, BLOB)
             * @enum {string}
             */
            type: "TEXT" | "INTEGER" | "REAL" | "BLOB";
            /** @description NOT NULL constraint */
            notNull?: boolean;
            /** @description Default value */
            default?: unknown;
            /** @description Foreign key reference (format: "table.column") */
            references?: string;
        };
        TableSchemaResponse: {
            columns?: {
                name?: string;
                /** @enum {string} */
                type?: "INTEGER" | "TEXT" | "REAL" | "BLOB";
            }[];
            primaryKey?: string;
            foreignKeys?: {
                column?: string;
                /** @description Format: table.column */
                references?: string;
            }[];
        };
        ColumnDefinition: {
            /**
             * @description Column data type
             * @enum {string}
             */
            type?: "text" | "integer" | "real" | "blob";
            /** @default false */
            primaryKey: boolean;
            /** @default false */
            unique: boolean;
            /** @default false */
            notNull: boolean;
            /** @description Default value for the column */
            default?: unknown;
            /** @description Foreign key reference (format: table.column) */
            references?: string;
            /** @enum {string} */
            onDelete?: "no action" | "restrict" | "set null" | "set default" | "cascade";
            /** @enum {string} */
            onUpdate?: "no action" | "restrict" | "set null" | "set default" | "cascade";
        };
        CreateTableRequest: {
            [key: string]: components["schemas"]["ColumnDefinition"];
        };
        NewColumnDefinition: {
            /** @enum {string} */
            type?: "text" | "integer" | "real" | "blob";
            /** @default false */
            notNull: boolean;
            /** @description Default value */
            default?: unknown;
            references?: string;
            /** @enum {string} */
            onDelete?: "no action" | "restrict" | "set null" | "set default" | "cascade";
            /** @enum {string} */
            onUpdate?: "no action" | "restrict" | "set null" | "set default" | "cascade";
        };
        AlterTableRequest: {
            /** @description New name for the table */
            newName?: string;
            /** @description Map of old column name to new column name */
            renameColumns?: {
                [key: string]: string;
            };
            /** @description New columns to add */
            newColumns?: {
                [key: string]: components["schemas"]["NewColumnDefinition"];
            };
            /** @description Columns to drop */
            dropColumns?: string[];
        };
        DatabaseInfo: {
            name?: string;
            id?: number;
        };
        CreateDatabaseRequest: {
            /** @description Database name */
            name: string;
            /**
             * @description Turso database group
             * @default default
             */
            group: string;
        };
        RegisterDatabaseRequest: {
            /** @description Name of the existing database to register */
            name: string;
        };
        CreateFTSIndexRequest: {
            /**
             * @description List of TEXT columns to include in the FTS index.
             *     All columns must be TEXT type.
             * @example [
             *       "title",
             *       "content"
             *     ]
             */
            columns: string[];
        };
        FTSIndexInfo: {
            /** @description Name of the source table */
            table?: string;
            /** @description Name of the FTS5 virtual table (always {table}_fts) */
            ftsTable?: string;
            /** @description Columns included in the FTS index */
            columns?: string[];
        };
        /** @description Schema template for multi-tenant database management */
        SchemaTemplate: {
            /** @description Template ID */
            id: number;
            /** @description Template name */
            name: string;
            /** @description Table definitions for this template */
            tables: components["schemas"]["Table"][];
            /** @description ISO timestamp of creation */
            createdAt: string;
            /** @description ISO timestamp of last update */
            updatedAt: string;
        };
        /** @description Result of syncing a template to a database */
        SyncResult: {
            /** @description Database name */
            database: string;
            /** @description Whether the sync was successful */
            success: boolean;
            /** @description Error message if sync failed */
            error?: string;
            /** @description List of changes applied */
            changes?: string[];
        };
        /** @description Result of syncing a single database to its template */
        DatabaseSyncResult: {
            /** @description Whether the sync was successful */
            success: boolean;
            /** @description List of changes applied */
            changes: string[];
        };
    };
    responses: {
        /** @description Bad request */
        BadRequest: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorResponse"];
            };
        };
        /** @description Unauthorized - missing or invalid API key */
        Unauthorized: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorResponse"];
            };
        };
        /** @description Resource not found */
        NotFound: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorResponse"];
            };
        };
        /** @description Rate limit exceeded */
        RateLimited: {
            headers: {
                /** @description Seconds until rate limit resets */
                "Retry-After"?: number;
                [name: string]: unknown;
            };
            content: {
                /**
                 * @example {
                 *       "error": "rate limit exceeded"
                 *     }
                 */
                "application/json": components["schemas"]["ErrorResponse"];
            };
        };
    };
    parameters: {
        /** @description Table name */
        TablePath: string;
        /** @description Target database name (default is primary database) */
        DBNameHeader: string;
        /**
         * @description Columns to return. Supports nested relations and aggregate functions.
         *
         *     **Column Selection:**
         *     - `*` - All columns
         *     - `id,name,email` - Specific columns
         *     - `*,posts(title,body)` - Include related posts
         *
         *     **Aggregations:**
         *     - `count(*)` - Count all rows
         *     - `sum(price)` - Sum a column
         *     - `avg(rating)` - Average a column
         *     - `min(age),max(age)` - Min/max values
         *     - `category,count(*),sum(price)` - Group by with aggregates
         *
         *     **Aliases:**
         *     - `alias:column` - Rename output field
         *     - `total:sum(price)` - Alias for aggregate
         */
        SelectParam: string;
        /**
         * @description Sort order for results.
         *
         *     Examples:
         *     - `name:asc` - Ascending by name
         *     - `created_at:desc` - Descending by created_at
         */
        OrderParam: string;
        /** @description Maximum number of rows to return (default 100, max 1000) */
        LimitParam: number;
        /** @description Number of rows to skip (for pagination) */
        OffsetParam: number;
        /**
         * @description Combine conditions with OR logic.
         *
         *     Example: `or=(status.eq.active,status.eq.pending)`
         */
        OrParam: string;
        /**
         * @description Set to `only` to get only the count of matching rows without data.
         *
         *     Returns `{ "count": N }` instead of row data.
         */
        CountParam: "only";
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getHealth: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Service is healthy */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "status": "healthy"
                     *     }
                     */
                    "application/json": components["schemas"]["HealthResponse"];
                };
            };
            /** @description Service is unhealthy */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "status": "unhealthy",
                     *       "error": "database ping failed"
                     *     }
                     */
                    "application/json": components["schemas"]["HealthResponse"];
                };
            };
        };
    };
    selectRows: {
        parameters: {
            query?: {
                /**
                 * @description Columns to return. Supports nested relations and aggregate functions.
                 *
                 *     **Column Selection:**
                 *     - `*` - All columns
                 *     - `id,name,email` - Specific columns
                 *     - `*,posts(title,body)` - Include related posts
                 *
                 *     **Aggregations:**
                 *     - `count(*)` - Count all rows
                 *     - `sum(price)` - Sum a column
                 *     - `avg(rating)` - Average a column
                 *     - `min(age),max(age)` - Min/max values
                 *     - `category,count(*),sum(price)` - Group by with aggregates
                 *
                 *     **Aliases:**
                 *     - `alias:column` - Rename output field
                 *     - `total:sum(price)` - Alias for aggregate
                 */
                select?: components["parameters"]["SelectParam"];
                /**
                 * @description Sort order for results.
                 *
                 *     Examples:
                 *     - `name:asc` - Ascending by name
                 *     - `created_at:desc` - Descending by created_at
                 */
                order?: components["parameters"]["OrderParam"];
                /** @description Maximum number of rows to return (default 100, max 1000) */
                limit?: components["parameters"]["LimitParam"];
                /** @description Number of rows to skip (for pagination) */
                offset?: components["parameters"]["OffsetParam"];
                /**
                 * @description Combine conditions with OR logic.
                 *
                 *     Example: `or=(status.eq.active,status.eq.pending)`
                 */
                or?: components["parameters"]["OrParam"];
                /**
                 * @description Set to `only` to get only the count of matching rows without data.
                 *
                 *     Returns `{ "count": N }` instead of row data.
                 */
                count?: components["parameters"]["CountParam"];
            };
            header?: {
                /** @description Target database name (default is primary database) */
                "DB-Name"?: components["parameters"]["DBNameHeader"];
                /** @description Set to `count=exact` to include total row count in X-Total-Count header */
                Prefer?: "count=exact";
            };
            path: {
                /** @description Table name */
                table: components["parameters"]["TablePath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Rows matching the query */
            200: {
                headers: {
                    /** @description Total row count (when Prefer count=exact is set) */
                    "X-Total-Count"?: number;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>[] | components["schemas"]["CountResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    insertRow: {
        parameters: {
            query?: {
                /**
                 * @description Columns to return. Supports nested relations and aggregate functions.
                 *
                 *     **Column Selection:**
                 *     - `*` - All columns
                 *     - `id,name,email` - Specific columns
                 *     - `*,posts(title,body)` - Include related posts
                 *
                 *     **Aggregations:**
                 *     - `count(*)` - Count all rows
                 *     - `sum(price)` - Sum a column
                 *     - `avg(rating)` - Average a column
                 *     - `min(age),max(age)` - Min/max values
                 *     - `category,count(*),sum(price)` - Group by with aggregates
                 *
                 *     **Aliases:**
                 *     - `alias:column` - Rename output field
                 *     - `total:sum(price)` - Alias for aggregate
                 */
                select?: components["parameters"]["SelectParam"];
            };
            header?: {
                /** @description Target database name (default is primary database) */
                "DB-Name"?: components["parameters"]["DBNameHeader"];
                /** @description Set to `resolution=merge-duplicates` for upsert behavior */
                Prefer?: "resolution=merge-duplicates";
            };
            path: {
                /** @description Table name */
                table: components["parameters"]["TablePath"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    [key: string]: unknown;
                } | {
                    [key: string]: unknown;
                }[];
            };
        };
        responses: {
            /** @description Row inserted successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InsertResponse"] | components["schemas"]["RowsAffectedResponse"] | Record<string, never>[];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            /** @description Conflict (unique constraint violation) */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "error": "record already exists"
                     *     }
                     */
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            429: components["responses"]["RateLimited"];
        };
    };
    deleteRows: {
        parameters: {
            query?: {
                /**
                 * @description Columns to return. Supports nested relations and aggregate functions.
                 *
                 *     **Column Selection:**
                 *     - `*` - All columns
                 *     - `id,name,email` - Specific columns
                 *     - `*,posts(title,body)` - Include related posts
                 *
                 *     **Aggregations:**
                 *     - `count(*)` - Count all rows
                 *     - `sum(price)` - Sum a column
                 *     - `avg(rating)` - Average a column
                 *     - `min(age),max(age)` - Min/max values
                 *     - `category,count(*),sum(price)` - Group by with aggregates
                 *
                 *     **Aliases:**
                 *     - `alias:column` - Rename output field
                 *     - `total:sum(price)` - Alias for aggregate
                 */
                select?: components["parameters"]["SelectParam"];
            };
            header?: {
                /** @description Target database name (default is primary database) */
                "DB-Name"?: components["parameters"]["DBNameHeader"];
            };
            path: {
                /** @description Table name */
                table: components["parameters"]["TablePath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Rows deleted successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RowsAffectedResponse"] | Record<string, never>[];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    updateRows: {
        parameters: {
            query?: {
                /**
                 * @description Columns to return. Supports nested relations and aggregate functions.
                 *
                 *     **Column Selection:**
                 *     - `*` - All columns
                 *     - `id,name,email` - Specific columns
                 *     - `*,posts(title,body)` - Include related posts
                 *
                 *     **Aggregations:**
                 *     - `count(*)` - Count all rows
                 *     - `sum(price)` - Sum a column
                 *     - `avg(rating)` - Average a column
                 *     - `min(age),max(age)` - Min/max values
                 *     - `category,count(*),sum(price)` - Group by with aggregates
                 *
                 *     **Aliases:**
                 *     - `alias:column` - Rename output field
                 *     - `total:sum(price)` - Alias for aggregate
                 */
                select?: components["parameters"]["SelectParam"];
            };
            header?: {
                /** @description Target database name (default is primary database) */
                "DB-Name"?: components["parameters"]["DBNameHeader"];
            };
            path: {
                /** @description Table name */
                table: components["parameters"]["TablePath"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                /**
                 * @example {
                 *       "name": "Alice Updated",
                 *       "email": "alice.new@example.com"
                 *     }
                 */
                "application/json": {
                    [key: string]: unknown;
                };
            };
        };
        responses: {
            /** @description Rows updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RowsAffectedResponse"] | Record<string, never>[];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    getSchema: {
        parameters: {
            query?: never;
            header?: {
                /** @description Target database name (default is primary database) */
                "DB-Name"?: components["parameters"]["DBNameHeader"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of tables */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example [
                     *       {
                     *         "name": "users",
                     *         "pk": "id",
                     *         "columns": [
                     *           {
                     *             "name": "id",
                     *             "type": "INTEGER"
                     *           },
                     *           {
                     *             "name": "email",
                     *             "type": "TEXT"
                     *           },
                     *           {
                     *             "name": "name",
                     *             "type": "TEXT"
                     *           }
                     *         ]
                     *       },
                     *       {
                     *         "name": "posts",
                     *         "pk": "id",
                     *         "columns": [
                     *           {
                     *             "name": "id",
                     *             "type": "INTEGER"
                     *           },
                     *           {
                     *             "name": "title",
                     *             "type": "TEXT"
                     *           },
                     *           {
                     *             "name": "user_id",
                     *             "type": "INTEGER"
                     *           }
                     *         ]
                     *       }
                     *     ]
                     */
                    "application/json": components["schemas"]["Table"][];
                };
            };
            401: components["responses"]["Unauthorized"];
            429: components["responses"]["RateLimited"];
        };
    };
    executeSchema: {
        parameters: {
            query?: never;
            header?: {
                /** @description Target database name (default is primary database) */
                "DB-Name"?: components["parameters"]["DBNameHeader"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                /**
                 * @example {
                 *       "query": "CREATE INDEX idx_users_email ON users(email)",
                 *       "args": []
                 *     }
                 */
                "application/json": components["schemas"]["SchemaQueryRequest"];
            };
        };
        responses: {
            /** @description Schema modified successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "message": "schema edited"
                     *     }
                     */
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            429: components["responses"]["RateLimited"];
        };
    };
    invalidateSchema: {
        parameters: {
            query?: never;
            header?: {
                /** @description Target database name (default is primary database) */
                "DB-Name"?: components["parameters"]["DBNameHeader"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Schema cache invalidated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "message": "schema invalidated"
                     *     }
                     */
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            429: components["responses"]["RateLimited"];
        };
    };
    getTableSchema: {
        parameters: {
            query?: never;
            header?: {
                /** @description Target database name (default is primary database) */
                "DB-Name"?: components["parameters"]["DBNameHeader"];
            };
            path: {
                /** @description Table name */
                table: components["parameters"]["TablePath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Table schema */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "columns": [
                     *         {
                     *           "name": "id",
                     *           "type": "INTEGER"
                     *         },
                     *         {
                     *           "name": "name",
                     *           "type": "TEXT"
                     *         },
                     *         {
                     *           "name": "email",
                     *           "type": "TEXT"
                     *         },
                     *         {
                     *           "name": "created_at",
                     *           "type": "TEXT"
                     *         }
                     *       ],
                     *       "primaryKey": "id",
                     *       "foreignKeys": [
                     *         {
                     *           "column": "org_id",
                     *           "references": "organizations.id"
                     *         }
                     *       ]
                     *     }
                     */
                    "application/json": components["schemas"]["TableSchemaResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    createTable: {
        parameters: {
            query?: never;
            header?: {
                /** @description Target database name (default is primary database) */
                "DB-Name"?: components["parameters"]["DBNameHeader"];
            };
            path: {
                /** @description Table name */
                table: components["parameters"]["TablePath"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                /**
                 * @example {
                 *       "id": {
                 *         "type": "integer",
                 *         "primaryKey": true
                 *       },
                 *       "name": {
                 *         "type": "text",
                 *         "notNull": true
                 *       },
                 *       "email": {
                 *         "type": "text",
                 *         "unique": true
                 *       },
                 *       "org_id": {
                 *         "type": "integer",
                 *         "references": "organizations.id",
                 *         "onDelete": "cascade"
                 *       }
                 *     }
                 */
                "application/json": components["schemas"]["CreateTableRequest"];
            };
        };
        responses: {
            /** @description Table created successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "message": "table users created"
                     *     }
                     */
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            429: components["responses"]["RateLimited"];
        };
    };
    dropTable: {
        parameters: {
            query?: never;
            header?: {
                /** @description Target database name (default is primary database) */
                "DB-Name"?: components["parameters"]["DBNameHeader"];
            };
            path: {
                /** @description Table name */
                table: components["parameters"]["TablePath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Table dropped successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "message": "table users dropped"
                     *     }
                     */
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    alterTable: {
        parameters: {
            query?: never;
            header?: {
                /** @description Target database name (default is primary database) */
                "DB-Name"?: components["parameters"]["DBNameHeader"];
            };
            path: {
                /** @description Table name */
                table: components["parameters"]["TablePath"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AlterTableRequest"];
            };
        };
        responses: {
            /** @description Table altered successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "message": "table users altered"
                     *     }
                     */
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    listFTSIndexes: {
        parameters: {
            query?: never;
            header?: {
                /** @description Target database name (default is primary database) */
                "DB-Name"?: components["parameters"]["DBNameHeader"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of FTS indexes */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example [
                     *       {
                     *         "table": "articles",
                     *         "ftsTable": "articles_fts",
                     *         "columns": [
                     *           "title",
                     *           "content"
                     *         ]
                     *       },
                     *       {
                     *         "table": "products",
                     *         "ftsTable": "products_fts",
                     *         "columns": [
                     *           "name",
                     *           "description"
                     *         ]
                     *       }
                     *     ]
                     */
                    "application/json": components["schemas"]["FTSIndexInfo"][];
                };
            };
            401: components["responses"]["Unauthorized"];
            429: components["responses"]["RateLimited"];
        };
    };
    createFTSIndex: {
        parameters: {
            query?: never;
            header?: {
                /** @description Target database name (default is primary database) */
                "DB-Name"?: components["parameters"]["DBNameHeader"];
            };
            path: {
                /** @description Table name */
                table: components["parameters"]["TablePath"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                /**
                 * @example {
                 *       "columns": [
                 *         "title",
                 *         "content"
                 *       ]
                 *     }
                 */
                "application/json": components["schemas"]["CreateFTSIndexRequest"];
            };
        };
        responses: {
            /** @description FTS index created successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "message": "FTS index created for table articles"
                     *     }
                     */
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    dropFTSIndex: {
        parameters: {
            query?: never;
            header?: {
                /** @description Target database name (default is primary database) */
                "DB-Name"?: components["parameters"]["DBNameHeader"];
            };
            path: {
                /** @description Table name */
                table: components["parameters"]["TablePath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description FTS index dropped successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "message": "FTS index dropped for table articles"
                     *     }
                     */
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
    listDatabases: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of registered databases */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example [
                     *       {
                     *         "name": "production-db",
                     *         "id": 1
                     *       },
                     *       {
                     *         "name": "staging-db",
                     *         "id": 2
                     *       }
                     *     ]
                     */
                    "application/json": components["schemas"]["DatabaseInfo"][];
                };
            };
            401: components["responses"]["Unauthorized"];
            429: components["responses"]["RateLimited"];
        };
    };
    createDatabase: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                /**
                 * @example {
                 *       "name": "my-new-db",
                 *       "group": "default"
                 *     }
                 */
                "application/json": components["schemas"]["CreateDatabaseRequest"];
            };
        };
        responses: {
            /** @description Database created successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "message": "database my-new-db created"
                     *     }
                     */
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            429: components["responses"]["RateLimited"];
        };
    };
    registerDatabase: {
        parameters: {
            query?: never;
            header?: {
                /** @description Optional database authentication token */
                "DB-Token"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                /**
                 * @example {
                 *       "name": "existing-db"
                 *     }
                 */
                "application/json": components["schemas"]["RegisterDatabaseRequest"];
            };
        };
        responses: {
            /** @description Database registered successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "message": "database existing-db registered"
                     *     }
                     */
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            429: components["responses"]["RateLimited"];
        };
    };
    registerAllDatabases: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description All databases registered successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["BadRequest"];
            401: components["responses"]["Unauthorized"];
            429: components["responses"]["RateLimited"];
        };
    };
    deleteDatabase: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Database name */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Database deleted successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "message": "database my-db deleted"
                     *     }
                     */
                    "application/json": components["schemas"]["MessageResponse"];
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["RateLimited"];
        };
    };
}
